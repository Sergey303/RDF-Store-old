Проект PolarDB 
==================   

(читается по-русски также как и по-английски - с ударением на первый слог и без смягчения 'a' - не как 'я'. Концовка читается ди-би.)

PolarDB - система конструирования специализированных СУБД, основанная на типовой системе языка Поляр (Polar) [1, 2].

Концепция подхода
==================   

Задача проекта заключается в том, чтобы создать эффективные средства представления данных в виде файловых построений. 
Причем файлы могут быть распределены по файловой системе или по сети компьютеров. Последнее - работа в рамках второго 
этапа проекта. Способ достижения эффективности - опора на строгую типизацию хранимых и обрабатываемых данных, минимизация
чтений из файлов и записей в файлы, минимизация перемещений указателя потока Position. 


Определения и комментарии
=========================   


Структурное значение (structured value, p-value) - древовидное построение (значение), интерпретируемое в 
соответствии с заданным типом.

Тип (Type, p-type) - древовидное построение, задающее интерпретацию для структурных значений. Может быть выражено как 
структурное значение. 

Тип может быть примитивным или атомарным (primitive types) или конструируемым (constructed types) или строками (strings).
Примитивные типы:
boolean, character, integer, longinteger, real и, кроме того, тип none - множество значений, не содержащее ни одного элемента.
Конструируемые типы: 
- запись (record) - фиксированный набор типизированных полей. Есть поля 0, 1, ... n-1, каждое из которых представляет значение
заданного в определении записи типа. Количество полей - фиксировано, типы полей - фиксированы.
- последовательность (sequence) - упорядоченный набор, состоящий из неопределенного (ноль или более) числа однотипных 
элементов. 
- объединение (union) - значение, состоящее из тега и подзначения. Тег (динамически) определяет вариант типа для подзначения.
Теги нумеруются, начиная с 0.
Строки: sstring - соответствует понятию (системной) строки в объектно-ориентированном программировании. 
Отличается от последовательности символов тем, что длина объекта sstring меньше 2 Гбайт. Реально может быть еще меньше.  

Пакет определений PType - дает определения общих представлений типов и определения объектов PType. 
Объекты класса PType - объекты C#, задающие тип (p-type). 

Голова значения (head of value) - та часть значения, которая располагается в сплошном куске хранения и имеет фиксированный
размер.

Размер головы (head size) - обычно относится к типу и означает количество байтов, занимаых головой значения.

Хвост значения (tail of value) - части значения, которые не вошли в голову.    

Ячейка (Cell) - хранилище для структурного значения. Ячейка всегда типизирована и предназначена для хранения значений только
данного типа. Ячейка может быть пустой (empty), если она не пустая, она хранит какое-то значение. Ячейка, как правило, связана
с файлом, в котором и хранится значение. Файл является файлом прямого доступа и он бинарный, т.е. там нет строк и их концов.
Ячейка следует системным (.NET) правилам общей работы с файлами. В случае, когда ячейка может использоваться разными программами
по чтению и записи, необходима пользовательская синхронизация. Ячейка может быть открыта на чтение, либо и на чтение и на
запись. В случае последовательной работы с ячейкой в режиме сначала запись, а потом только чтение, рекомендуется после
записи ячейку закрывать и открывать уже только на чтение. Ячейка может быть временно блокирована, хотя детали такой 
синхронизации пока не ясны.

Ячейка может быть фиксированного (fixed) формата или произвольного (свободного, добавляемого, appending) формата.
Ячейки произвольного формата предназначены для хранения и доступа к значению, разово помещенному в ячейку при ее заполнении,
есть существенное исключение, об этом - позже.
Ячейки фиксированного формата предназначены для хранения, прямого доступа и модификации значения, помещенного в ячейку.
Ячейки произвольного доступа, как правило, хранят значения в более компактном представлении, но ячейки фиксированного 
формата позволяют добраться (от корня) до нужного поля существенно быстрее и позволяют модифицировать поля, убавлять и
добавлять значения в последовательности. 

Ячейки обоих форматов вначале файла устроены одинаково. Это - специальный код для контроля, что идет работа с файлом
базы данных и файлом нужного формата. Потом идет offset начала данных. Если данных нет, то offset указывает на
конец файла. Потом идет сериализованный тип в совободном представлении (в настояще время, такая запись не оуществляется). 
Ячейки могут быть, а иногда должны быть очищены от значения методом Clear(). При этом, ячейка становится пустой 
(cell.IsEmpty == true) и готовой ко вводу данных. Для ячейки фиксированного формата, метод Clear() очищает голову 
(размечает нулями) и формально, ячейка не пустая и имеет какое-то значение. Clear() не корректирует текущий размер файла, 
он остается тем, который накопился при предыдущей работе. В дальнейшем, возможно будет сделан какой-то метод типа Trim(), но
пока, если хочется, чтобы размер файла в подобном случае был минимальный, рекомендуется закрыть ячейку, уничтожить 
файл и снова открыть (пустую) ячейку.

После заполнения ячейки данными или в конце сеанса, в котором данные модифицировались, ячейку надо "доделать" методом Flush() 
или "закрыть" методом Close(). После Flush() ячейка все еще доступна для работы, после Close(), она для работы не доступна. 

Кроме того, в динамической части ячеки PCell имеется поле long nElements, которое осмысленно только если ячейка хранит 
последовательность. В этом случае, в поле дублируется число элементов последовательности. Это позволяет (сильно) экономить 
на "перемещениях" "головки записи", например в методе AppendElement. Надо иметь ввиду, что значение nElements может "разойтись" 
со значением поля длины последовательности, записанным в файле. Синхронизация выполняется методом Flush().

Текстовая интерпретация структурного значения. Если задан тип и задано значение, соответствующее этому типу, возможно его 
превратить в текстовую строку (проинтерпретировать). Интерпретация осуществляется в следующих лексике и синтаксисе:
- атомарные величины и строки изображаются в стандартном для программных представлений виде: булевские в виде соответствующей 
булевской константы, символы в виде символа в одинарных кавычках, целые, длинные целые и вещественные в стандартном для чисел 
виде, строки - в виде последовательности символов, входящих в строку, обрамленной двойными кавычками. 
- запись изображается в виде открывающей фигурной скобки, потом идут изображения полей записи, разделенные запятыми, потом
идет закрывающая фигурная скобка.
- последовательность изображается начиная с открывающей квадратной скобки, далее идут изображения элементов последовательности,
разделенные запятыми, потом идет закрывающая квадратная скобка.
- объединение изображается в виде идентификатора, соответствующего имени зафиксированного варианта, далее идет знак "^" и
далее изображение подзначения.
- значение типа none не изображается (пустая последовательности символов).
Для выдачи значений записи существует также полный формат, когда каждое поле записи предваряется именем поля и двоеточием.

Текстовая интерпретация структурных значений используется, в основном для ввода данных в коде и для отладки. 

Пока были введены только сами типы. Однако, они также представляют собой структурные значения. Их тип (тип типа) это  
статическая константа TType, имеющаяся в составе пакета PType. Эта константа используется для внутренних системных целей.
Ею можно воспользоваться для выдачи тестовой интерпретации вводимых типов. Например, фрагмент программы:
            PType typ = new PTypeRecord(
                new NamedType("f1", new PType(PTypeEnumeration.sstring)),
                new NamedType("f2", new PTypeSequence(new PType(PTypeEnumeration.integer))));
            var tt = PType.TType;
            var s = tt.Interpret(PType.topobject( typ ));
            Console.WriteLine(s);
выдаст текстовую интерпретацию объекта, соответствующего типу typ в контексте его типа TType. Получается что-то вроде
  record^[{"f1", sstring^}, {"f2", sequence^integer^}]

Объектная форма представления структурных значений. Структурные значения или их части (в силу рекурсивности построения
структурных значений) могут существовать в виде объектов системы программирования. Вид такого представления - самый общий,
это object. Атомарные значения представляются в виде значений соответствующих системных типов или классов: bool, char, int,
long, double. Строки представляются строками. Составные (конструируемые) значения представляются в виде массивов объектов 
object[]. Причем для записи, элементы массива соответствуют полям записи, для последовательности, элементы массива 
соответствуют элементам последовательности, для объединения - массив состоит из двух элементов. Первый имеет целочисленное
значение и соответствует индексу тега, второй элемент массива соответствует подзначению объединения. 

Объектное представление можно сохранить в ячейке или поле (входе) ячейки (про входы, см. далее) и может быть прочитано 
из ячейки или ее входа. 

Эквивалентность структурных значений. Структурные значения считаются эквивалентными (равными) если ... (пока определить я
затрудняюсь, возможно надо через объектные представления).

Эквивалентность объектных представлений структур. Объектные представления двух структурных значений для атомарных значений и
строк определяется равенством соответствующих значений. Для конструируемых объектов, выраженных object[], оба массива должны
быть одной размерности и их компоненты должны быть эквивалентными.   

Входы (Entries). Входами в хранимое структурное значение называются указатели специального вида, позволяющие выполнять
чтение или, в некоторых случаях, запись подобъекта из/в данную позицию. Входы вычисляются через от указателей на более 
высокоуровневые структуры к подструктурам. Например если вход установлен на запись, то методом Field(i) можно вычислить
вход на поле записи. Входы различаются для ячеек свободного формата и ячеек фиксированного формата. Входы для ячеек
свободного формата задаются C# структурой PaEntry, входы для ячеек фиксированного формата задаются структурой PxEntry.
Входы также могут быть "сконструированы" через конструктур или изменение поля offset уже вычисленного входа.

Первично, вход появляется как корень ячейки: cell.Root задает вход для корня хранящейся в ячейке структуры. 
Для незаполненной ячейки свободного формата, свойство Root не определено. Незаполненные ячейки фиксированного формата 
сразу имеют голову, размеченную нулями. Поэтому и незаполенная или очищенная ячейка фиксированного формата имеет осмысленный 
корень. Здесь есть одна тонкость. Если тип значения является объединением, то его варианты перечисляются начиная с нуля.
Если нулевой вариант имеет атомарный или другой "безхвостовый" вид, то все в порядке - значение будет осмысленным.
Если же возможен "хвост", то размеченное нулями значение, может быть неправильно интерпретировано как структура. 
Чтобы избежать подобной опасности, достаточно, чтобы у перечислений, нулевой вариант был атомарным. Часто это делается
искусственно, как в вариантах для триплета:
triplet = empty^none,
          op^{subject: string, predicate: string, obj: string},
		  dp^{subject: string, predicate: string, data: string, lang: string}; 

Методы, вычисляющие входы следующие:
Field(int i) - поле записи,
Element(long ii) - поле элемента последовательности,
UElement() - подэлемент объединения
UElementUnckecked(int tag) - подэлемент объединения без проверки записанного индекса тега

Другими данными, которые можно получить на входах являются:
Count() - длинное целое - число элементов последовательности,
Tag() - индекс варианта объединения

Имея вход можно прочитать структурное значение этого входа методом Get() или записать в этот вход новое значение
методом Set(object v). Метод Set определен лишь частично для входов в ячейки свободного формата. Эта частичность заключается
в том, что изменять можно лишь данные, размер которых полностью совпадает с размером уже записанных. Это можно делать для
"безхвостовых" данных, тип которых имеет свойство HasNoTail.  

Также для входов в последовательности определена генерация потока входов в элементы последовательности
Elements().

Для последовательностей, существуют редактирующие воздействия:
long AppendElement(object valu); // выдает offset, по которому элемент был записан в ячейку (существенно для свободного формата)
void DeleteElement(int index);
void InsertElementBefore(int index, object valu);

Для ячеек свободного формата, определена только операция добавления AppendElement() и то только в тому случае, когда 
добавление идет в корень и ячейка не пустая. 

Для ячеек фиксированного формата, пока методы не реализованы. 

Возможно, надо будет добавить еще AppendRange(object[] values).


Заполнение ячейки данными. Ячейка является хранилищем данных и ее нужно заполнять. Ячейки свободного формата
заполняются однократно с точностью до перезаполнений после очистки Clear(). Есть два метода заполнения ячейки
свободного формата. Первый метод - Fill(object value). Эти методом объект value заполняет ячейку. Этот способ
годится только для небольших объектов, которые помещаются в оперативной памяти или ее "не напрягают".
Другой способ - через скобочный структурный поток (см. далее). 

Заполнение ячеек фиксированного формата производится несколько по-другому. Ячейка фиксированного формата, всегда 
содержит значение. Даже если она только что инициализирована или очищена. Поэтому у нее всегда есть входы.
Вместо заполнения данными, для входов в ячейку определен метод Set(object valu) при котором объект замещает 
то структурное значение, которое там было. Предыдущее значение становится недоступным - голова просто стирается 
накладыванием новой головы, хвост, остается, но становится "мусором". Пока сборки мусора не предусмотрено. 
Также как и для ячеек свободного формата, существует потоковый ввод данных. Но делается это через другой вид
потока - польский (см. далее).     
 
Скобочный структурный поток (Serial structure flow) - поток объектов, объектных структур и "скобок" в соответствии со 
спецификацией пакета SerialFlow. Поток используется для ввода или передачи структурных данных в ячейку свободного
формата. 

Польский структурный поток (Polish structure flow) - поток объектов в "польской" развертке. Определяется он следующим образом:
а) Атомарные элементы и строки - прямо помещаются в поток. Значение типа none помещается (?) в виде null.
б) Последовательность помещается в поток либо структурным объектом, либо потоком элементов, предваряемым длинным целым - длиной
последовательности. Это целое является отличительным признаком варианта ввода.
в) Объединение помещается в поток либо структурным объектом, либо двумя элементами - сначала идет целочисленный тег и это
является отличительным признаком развертки объединения, потом идет подзначение.
г) Запись помещается в поток либо структурным объектом, либо разверткой записи, т.е. отдельным специальным объектом 
(типа операции в польской записи), означающим начало развертки записи, потом потоком элементов записи.
Определения, требующиеся для работы с польским потоком, собраны в пакете PolishFlow.
Выдача польского потока, напр. из ячейки, осуществляется методом
IEnumerable<object> PolishOutputFlow(), задающим полную польскую развертку хранимого структурного значения. 

Сортировка последовательностей. Для последовательностей возможна сортировка элементов. Сортируемая
последовательность задается входом (Entity). Если последовательность свободного формата, то сортировку 
можно выполнять только если у элементов нет хвостов. Тогда все элементы одинакового размера. 

Для последовательностей свободного формата, 

Для последовательностей фиксированного формата, ограничений на элементы последовательности отсутствуют. 
Для последовательностей свободного формата, в параметре метода задается функция сравнения объектных представлений
элементов. Смысл функции - определить целым числом какой элемент "больше" или они "равны". Пример задания
сортировки:
            n4.Root.Sort((object o1, object o2) =>
            {
                object[] v1 = (object[])o1;
                object[] v2 = (object[])o2;
                string s1 = (string)v1[1];
                string s2 = (string)v2[1];
                return s1.CompareTo(s2);
            });
В данном случае, сортируется последовательность, находящаяся в корне ячейки. Последовательность состоит из записей,
сортировка производится по второму элементу имеющему строковое значение.

Для последовательностей фиксированного формата, функция порядка задается не на значениях, а на входах для элементов.
Есть два варианта задания такой функции задание порядка, в этом случае метод называется SortComparison, или заданием
ключевого значения, на котором определяется порядок. Второй способ экономнее (иногда намного), первый универсальнее.

Бинарные деревья. Бинарные деревья пока не вставлены в базу PolarDB и пока имеются только в виде демонстрационного
примера BinaryTree. Дерево реализовано в виде выстраивания объектов рекурсивного типа:
        BTree<T> = empty^none,
                   pair^{element: T, less: BTree<T>, more: BTree<T>};
В первой версии бинарного дерева было еще поле с числом элементов в данном поддереве. Пока это поле исключено
за ненадобностью для демонстрационных целей. Написан метод добавления в дерево элемента. Однако, для целей 
формирования дерева только этот метод недостаточен. Дерево строится "перекошенное", это приводит к большим 
задержкам при построении дерева и даже к переполнению стека в силу особенностей рекурсивной структуры программы.
Для демострационных целей был сделан "трюк", заключающийся в том, что сначала вводимые в дерево данные 
сортируются, а потом элементы подаются в порядке, благоприятном для построения сбаллансированного дерева.
Этот фрагмент работает, но показывает невысокие результаты в части скорости ввода. Было найдено приемлемое
решение, которое заключается в том, что вводимые данные (опять) сортируются, а потом строится бинарный объект,
сбаллансированного дерева. Этот объект вводится в помощью метода Fill2, который существенно эффективней Fill
для случаев сильно "разбрасываемых" данных. Получилось очень приличное решение. Можно сказать, что скорость ввода
индексных данных составляет (на моем слабеньком ноуте) около 40 тыс. записей в секунду. Эти результаты - 
предварительные.

Комментарии для разработчиков ядра
==================================

Главная идея оптимизации в том, что доступ к дисковым и прочим данным осуществляется существенно медленнее,
чем работа в оперативной памяти, а поэтому ускорять нужно именно его. Для этих целей используется: а) минимизация
чтений и записей из/в ячейку; б) минимизация перемещений позиции Position чтения/записи.

Спецификация и схема реализации SerialBuffer
============================================
SerialBuffer - класс, инстансы которого буферизируют поток ввода, осуществляемый через серийный
поток (методы ISerialFlow), превращая его в эквивалентный серийный поток для получателя, но с 
укрупнением порций V(value). Это укрупнение регулируется либо заданием slevel - "глубины" отслеживания,
либо фиксацией пределов использования оперативной памяти. Первое означает, что для глубины 0, все
значение накапливается в буфере, а потом уже выдается потребителю через V(value). Для глубины N,
на выходе будет строиться серийный поток с вложенностью скобок не более, чем N (при произвольной
вложенности скобок входного потока). 
Фиксация пределов означает, что серийный поток будет такой (динамически меняющейся) вложенности скобок, 
чтобы некоторый оценочный "объем" значений value не превышал порога. Это отслеживание объема выливается
в появление другой величины currentTreeDepth, аналогичной level, но динамически меняющейся в соотвествии
с вычислениями. slevel - фиксированное значение количества скобок внешнего уровня, которые в выходном
потоке превращаются в парные события R()-Re(), S()-Se(), U()-Ue(). currentTreeDepth является 
количеством уже открытых внешних скобок-событий R(), S(), U().   

Как это реализовывается?

Интерпретация входного потока осуществляется на стеке inputStack, элементы которого имеют тип:
    internal class TBStack
    {
        public PType nodeType;
        public long index;
        public object tvalue = null; // Место формирования объектного дерева данного типа, если null - то не получилось
		public long volume; 
    }
где nodeType - тип значения, накапливаемого на стеке,
index - позиция значения в вышестоящей структуре (для записи - номер поля, для последовательности -
номер элемента),
tvalue - накапливаемый элемент,
volume - накопленный объем значения tvalue, полученный как: для атомарных типов как некоторое 
значение, зависящее от типа и объекта, для структур - константа плюс длина массива, умноженная на 
коэффициент плюс сумма объемов элементов. Константа - 16, коэффициент - 8, функция вычисления 
объема для структурного значения 
        private static long Volume(object val);

 

Еще буфер поддерживает вычисление общего объема наколенных данных totalVolume, который определяется
как сумма всех объемов значений, накопленных в стеке. Эта величина нужна, по-крайней мере - для
отладки. Возможно ее более содержательное использование.

Инвариант следующий: все элементы, с меньшим индексом index, чем текущий ("старшие братья"), уже 
выведены из стека и находятся в виде index-1 элементов в вышестоящем элементе стека в поле tvalue,
которое в этом случае имеет текущий тип object[]. Есть отличия в этом значении при обработке
записи и последовательности. В случае записи, там находится сразу установленный по размеру массив
для элементов записи и index нижестоящего элемента определяет число уже заполненных в нем элементов
(остальные null). В случае последовательности, tvalue == null, до тех пор, пока не появится первый
элемент. После этого, tvalue становится растущим массивом, с текущим размером (определяемым по 
LongLenth) и текущим заполнением, определяемым индексом нижестоящего элемента. 

Ключевым изменением состояния, является завершение формирования элемента. Это изменение состояния
реализуется методом:
    private void FinalOperations(TBStack current);
На вход подается верхушка стека без "отщепления" ее от стека (т.е. ее можно не передавать, а
вычислять).
Метод вызывается в конце отработки V(), Re(), Se(), Ue(). Его функция - использовать накопленное
значение, возможно, присовокупить сформированное значение в массив вышестоящего элемента 
структуризации (и стека) и подготовить верхушку стека к приему следующего значения (если нужно). 

С подготовкой верхушки стека - проще. Для вышестоящей записи вычисляется тип следующего элемента
(на основе текущего индекса + 1), для записи, последовательности и объединения, индекс инкрементируется.
Могут возникнуть авосты: при попытке записать а запись более, чем определенное записью число
элементов; при попытке в объединение записать второе подзначение. 

Использование значения - дело тонкое. Значение, накопленное на этом уровне, либо надо "отправить" в 
выходной поток, либо его надо переписать в формируемый в головном элементе массив на позицию, 
имеющуюся в index. Посылкой значения в выходной поток занимается НЕ ТОЛЬКО FinalOperations.  
Условия для вариантов:
1) размер стека меньше, либо совпадает со значением уровня или текущей глубины:
inputStack.Count <= slevel + 1 || inputStack.Count <= currentTreeDepth + 1.
2) Размер стека больше обеих величин, т.е. отрицание предыдущего условия:
inputStack.Count > slevel + 1 && inputStack.Count > currentTreeDepth + 1.

В первом случае, нужно в выходной поток записать V(value).
Во втором, "стандартном" случае, когда не достигнуты ограничения, нужно значение переписать как 
следующее, в вышестоящий объект. Соответственно, перевычислить объемы. Но сам факт включения 
элемента в вышестоящую последовательность, может оказаться невозможным по причине ограничений. 
Тогда нужно начинать потоковым образом "сбрасывать" предыдущие и вышестоящие элементы. Сброс начинается
с уровня, следующего за текущей глубиной дерева currentTreeDepth, которая 
совпадает и числом предыдущих открывыющих скобок минус количество закрывающих. Естественно, 
предполагается правильная вложенность скобок. Замечу, что все незакрытые скобки, в текущем состоянии,
совпадают с элементами стека, начиная со старшего, ответственного за скобку первого уровня и
далее currentTreeDepth подряд стоящих элементов стека. 

Таким образом, когда приходим к ситуации, что буфер не может принять новые элементы в оперативную память, 
нужно, начиная уровня currentTreeDepth + 1 и до текущего уровня сбросить все накопленные элементы, 
проставляя открывающие скобки. И после этого, надо установить новую глубину на родительский элемент.
В итоге, вариант 2) будет переведен в вариант 1) и надо будет сбрасывать значение.   

Обратный процесс по уменьшению текущей глубины дерева происходит более постепенно. Когда закрывается 
структурная конструкция, т.е. появляется закрывающая скобка, нужно из текущей глубины, вычесть 1. 

Возможно, есть нюанс для объединений. Но как-то я не могу сообразить, позже будет видно. 

Теперь о вычислении значений. Для интерпретации входного потока, происходит некоторая работа на стеке.
Иногда эта работа заканчивается вычисленным значением, наколенным в поле tvalue, иногда - нет. Во втором
случае, все вычисленное при обработке данного узла уже отправлено в выходной поток. Граница - заботимся 
мы о tvalue или нет, все та же - условия 2) и 1). Обработка элемента стека, по имеющейся логике, это
обработка всех элементов ("братьев") структурной конструкции, родительской, по отношению к данной. Развилка 
в том, порождена родительской констукцией скобка или нет. Если порождена, то значения данного элемента
стека точно не нужны родителю, их надо сбрасывать через события. Но сбрасывать, когда они уже накопились
или сброс идет "распределенно", если ситуация рекуррентно провторяется. 

Таким образом, получается, что обработки R()-Re(), S()-Se(), U()-Ue() и V(value) все должны быть задействованы
формировании выходного потока. И в режиме 1) надо открывающим скобкам генерировать открывание скобок, 
закрывающим скобкам - генерировать закрытие скобок и уменьшение текущей глубины дерева.

Рассмотрим пограничный вариант. Когда размер стека лишь на 1 превышает текущую глубину дерева, т.е. числа 
открывающих скобок. Тогда внутренние элементы все вычисляются как значения (?). Действительно, если 
потребуется "развернуть" какое-то внутреннее значение, то и предыдущие будут превращены в события V() и 
делее все должно идти уже с увеличенной глубиной дерева. Вопрос здесь: как уменьшать глубину дерева. 
По крайней мере, сомнительно, чтобы ее можно было уменьшать по закрытию скобки, как это сейчас делается. 
Может и по закрытию, но с "запозданием" на один уровень. 
Я подумал, решил, что есть еще одна возможность: отмечать "изнутри", является ли сформированное значение
структурным объектом, который находится в tvalue, либо этот объект уже "сброшен". И тогда, когда мы уменьшаем
текущую глубину дерева, отметку dropped устанавливать в истину. Вроде, этот подход не требует "эпохальных" 
переделок, попробую.   

Польский поток
==============

Ячейки фиксированного формата PxCell можно заполнять не только с корня и до конца, но и частично - конкретный
вход PxEntry. Это означает, что можно не только применять к входу Set с полным объектом, который туда 
помещается, но и разбить объект на мелкие части, превратив в польский поток. Это снижает нагрузку на
оперативную память, а для больших информационных массивов, является естественным решением. Видимо, возможна и
обратная операция, когда вход выдает польский поток, но она менее актуальна, поскольку есть методы "мельчения",
определенные для входа. 

Интерфейс такого ввода, мог бы быть Get(IEnumerable<object>). Проблема такого интерфейса в том, что неясна
"судьба" промежуточного между источником и приемником потока. Возможно, сначала будет запускаться источник, 
потом, когда он сгенерирует весь поток, запускаться приемник. В одной из моих разработок эта схема работала 
откровенно плохо. Нужна буферизация. Будет ли она разумно делаться системой - это вопрос. Пропробую изменить
интерфейс и сделать что-то вроде Get(IPolishFlow source). Источник данных можно активировать методом 
StartPolishFlow(), можно дезактивировать методом EndPolishFlow() и можно читать выданный источником элемент
потока через метод object Read(). Таким образом, источник данных управляется не со стороны "себя",
а приемником данных. В простом случае, когда есть последовательность небольших записей или чего-то аналогичного, 
ридер выдает количество записей и далее, выдает записи одну за другой. В более сложном случае, видимо будет
требоваться буферизация.  



 
  
 

Проблемные спецификации
=======================

Запись значений в ячейку свободного (добавляемого) формата осуществляется подряд идущими полями разного размера, 
располагаюшимися непрерывно и в соответствии с "разверткой" полей объектного представления. Делается это методом 
Append(PType typ, object value). Причем "головка записи", т.е. указатель потока Position, должна быть установлена на
начало места для записи.

Обратное действие, т.е. чтение структурного значения из потока байтов свободного (добавляемого) формата осуществляет
метод 
object ScanObject(PType typ).
причем "головка чтения" должна быть установлена на начало фрагмента. Метод не используется в связи с наличием
алтернативного метода GET(), см. далее. Видимо, он будет устранен из базового комплекта.

 
 

Что нужно доделать
==================   

1. Метод Fill2(). Он также используется в Set(), но часть кода дублируется. Кроме того, нет ограничителя на длину 
очереди.

2. Предположительно, метод Get() должен "испытывать" те же затруднения, что и Set(). То есть, указатель места чтения из
файла может "дергаться". Надо рассмотреть возможность разбить метод на части (GetHead(), GetTail()) и очередь.

3. Для PaEntry не хватает метода бинарного поиска. Даже двух (первого и всех).

4. Нужно изменить схему реализации SerialBuffer отказавшись от использования zstack'а. А то,
при вводе длинной последовательности, там накапливается слишком длинный массив.

5. Изучить возможность работы с бинарными деревьями, в частности - динамического формирования с 
сохранением его сбалансированности. 

 


 
   
 
 

Источники

1. А. Г. Марчук, Т. И. Лельчук Язык программирования Поляр: описание. использование, реализация /  Под ред. В. Е. Котова; 
АН СССР, Сиб. отд-ние, ВЦ, Новосибирск ВЦ СО АН СССР 1986, 94 с.
2. G.M.Krecker, T.I.Lelchuk, A.G.Marchuk POLAR - A Programming Language for Multiprocessor Systems// 
Proceed. of the IFIP 11th World Computer Congress. - San Francesco, USA, 1989. P. 33-37. 